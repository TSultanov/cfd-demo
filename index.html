<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2D Fluid Flow Simulation with PISO Algorithm (Staggered Grid)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 10px;
    }
    #simulationContainer {
      display: flex;
      flex-wrap: wrap;
    }
    #controls {
      margin: 10px;
    }
    canvas {
      border: 1px solid #ccc;
      margin: 10px;
    }
    #residualText {
      width: 100%;
      height: 100px;
    }
  </style>
</head>
<body>
  <h1>2D Fluid Flow Simulation around a Cylindrical Obstacle (Staggered Grid)</h1>
  <div id="simulationContainer">
    <!-- Simulation visualization canvas -->
    <canvas id="simulationCanvas" width="1000" height="660"></canvas>
    <div id="controls">
      <h2>Visualization Controls</h2>
      <button id="velocityButton">Velocity Field</button>
      <button id="pressureButton">Pressure Field</button>
      <button id="vorticityButton">Vorticity Field</button>
      <button id="tracerButton">Tracer Particles</button>
      <!-- NEW: Checkbox to enable/disable tracer particles (default off) -->
      <br>
      <label for="tracerEnabledCheckbox">Enable Tracer Particles:</label>
      <input type="checkbox" id="tracerEnabledCheckbox">
      <h3>Legend</h3>
      <!-- Gradient legend with 10 ticks -->
      <canvas id="legendCanvas" width="200" height="30"></canvas>
      <p>
        Inlet: <span style="color: green">Green</span>, 
        Walls: <span style="color: magenta">Magenta</span>, 
        Outlet: <span style="color: blue">Blue</span>
      </p>
      <h2>Inlet Velocity Controls</h2>
      <label for="inletVelocitySlider">Velocity Magnitude (m/s):</label>
      <input type="range" id="inletVelocitySlider" min="0" max="5" step="0.1" value="1">
      <span id="inletVelocityValue">1</span>
      <br>
      <label for="inletProfileSelect">Velocity Profile:</label>
      <select id="inletProfileSelect">
        <option value="uniform">Uniform</option>
        <option value="parabolic">Parabolic</option>
      </select>
      <h2>Velocity Discretization Scheme</h2>
      <label for="velocitySchemeSelect">Scheme:</label>
      <select id="velocitySchemeSelect">
        <option value="first" selected>First-Order Upwind</option>
        <option value="second">Second-Order Upwind</option>
      </select>
      <h2>Time Step Control</h2>
      <label for="timeStepInput">Time Step (s):</label>
      <input type="number" id="timeStepInput" step="0.001" value="0.5">
      <p>Current dt: <span id="currentDtValue">0.5</span></p>
      <!-- Checkbox to enable/disable dt scaling by residuals -->
      <label for="residualScalingCheckbox">Enable dt scaling by residuals:</label>
      <input type="checkbox" id="residualScalingCheckbox">

      <!-- Viscosity Control -->
      <h2>Viscosity Control</h2>
      <label for="viscosityInput">Viscosity (m²/s):</label>
      <input type="number" id="viscosityInput" min="0.000001" max="0.1" step="0.000001" value="0.000001">

      <!-- Pressure Solver -->
      <h2>Pressure Solver</h2>
      <label for="pressureSolverSelect">Choose Pressure Solver:</label>
      <select id="pressureSolverSelect">
        <option value="jacobi" selected>Jacobi Iteration</option>
        <option value="sor">Successive Over-Relaxation (SOR)</option>
        <option value="multigrid">Multigrid V-Cycle</option>
      </select>

      <h2>Simulation Control</h2>
      <button id="startButton">Start</button>
      <button id="pauseButton">Pause</button>
      <button id="resetButton">Reset</button>
    </div>
  </div>
  
  <h2>Residuals Log (shows time step, substeps and residuals for each integration cycle)</h2>
  <textarea id="residualText" readonly></textarea>
  
  <h2>Residuals Graph</h2>
  <canvas id="residualCanvas" width="600" height="200"></canvas>
  
  <script>
    /******************** Simulation Setup and Global Variables ********************/
    // Adjust channel and obstacle dimensions for robust vortex street formation.
    const Nx = 400; // number of pressure cells in x (increased resolution for extended channel)
    const Ny = 132; // number of pressure cells in y for refined resolution
    const Lx = 30;  // channel length (longer domain to allow wake development)
    const Ly = 10;  // channel height (moderate confinement)
    const dx = Lx / Nx;
    const dy = Ly / Ny;
    
    // Global cylinder parameters for the obstacle (in SI units)
    const cylinderRadius = 0.75;  // updated cylinder radius for stronger blocking effect
    const cylinderCenterX = Lx / 4;  // updated: place cylinder at one-fourth of the channel length (e.g., x = 7.5 m)
    const cylinderCenterY = Ly / 2;  // center vertically remains unchanged

    // Canvas and contexts
    const canvas = document.getElementById("simulationCanvas");
    const ctx = canvas.getContext("2d");
    // Disable image smoothing to avoid grid (anti-aliasing) artifacts.
    ctx.imageSmoothingEnabled = false;

    const legendCanvas = document.getElementById("legendCanvas");
    const legendCtx = legendCanvas.getContext("2d");
    legendCtx.imageSmoothingEnabled = false; // likewise for legend if needed

    const residualCanvas = document.getElementById("residualCanvas");
    const residualCtx = residualCanvas.getContext("2d");

    const residualText = document.getElementById("residualText");

    // UI Elements
    const velocityButton = document.getElementById("velocityButton");
    const pressureButton = document.getElementById("pressureButton");
    const vorticityButton = document.getElementById("vorticityButton");
    const tracerButton = document.getElementById("tracerButton");
    const inletVelocitySlider = document.getElementById("inletVelocitySlider");
    const inletVelocityValue = document.getElementById("inletVelocityValue");
    const inletProfileSelect = document.getElementById("inletProfileSelect");
    const timeStepInput = document.getElementById("timeStepInput");
    const startButton = document.getElementById("startButton");
    const pauseButton = document.getElementById("pauseButton");
    const resetButton = document.getElementById("resetButton");
    // NEW viscosity UI elements
    const viscosityInput = document.getElementById("viscosityInput");
    // NEW: Pressure solver UI element and selection state
    const pressureSolverSelect = document.getElementById("pressureSolverSelect");
    let currentPressureSolver = pressureSolverSelect.value;
    const velocitySchemeSelect = document.getElementById("velocitySchemeSelect");
    let currentVelocityScheme = velocitySchemeSelect.value;  // "first" by default

    // Simulation state variables
    let simulationRunning = false;
    let simulationStepCount = 0;
    let substepCount = 5; // Initial number of sub-timesteps
    let dt = parseFloat(timeStepInput.value);
    let nu = 0.000001; // kinematic viscosity of water (m^2/s)
    let currentInletVelocity = 0;
    let targetInletVelocity = parseFloat(inletVelocitySlider.value);
    const rampUpSteps = 1000;  // Ramp inlet from 0 to set value over 1000 time steps
    let residualHistory = [];  // For graphing residuals over time

    // NEW: Global variable to control the current visualization mode
    let currentVisualization = "velocity";

    // NEW: In a staggered grid the arrays have different sizes.
    // Pressure p: defined on pressure cells (Nx x Ny)
    // u: horizontal velocity defined at vertical faces ((Nx+1) x Ny)
    // v: vertical velocity defined at horizontal faces (Nx x (Ny+1))
    let u, v, p;
    let obstacle; // obstacle mask on pressure grid (size Nx x Ny)

    // --- Pre-allocated temporary buffers to avoid dynamic allocations during simulation ---
    let uOld, vOld, uStar, vStar, rhs, pPrime, pPrime_new;

    // Before the Jacobi iterations, precompute constant denominators
    const dx2 = dx * dx;
    const dy2 = dy * dy;
    const denom = 2 / dx2 + 2 / dy2;
    const iterations = 50; // Try reducing iterations from 100 if accuracy permits

    // Precompute boolean mask for the cylindrical obstacle on the pressure grid
    let obstacleMask; // Global precomputed obstacle mask

    // Global variable to track the last pressure residual from pressure correction
    let lastPResidual = 0;

    // Global variable to control dt scaling based on residuals (default disabled)
    let residualScalingEnabled = false;

    // NEW: Global flag to control tracer particles (default off)
    let tracersEnabled = false;

    function precomputeObstacleMask() {
      obstacleMask = new Array(Nx * Ny).fill(false);
      for (let j = 0; j < Ny; j++){
        for (let i = 0; i < Nx; i++){
          let idx = i + j * Nx;
          // Pressure cell center position
          let x = (i + 0.5) * dx;
          let y = (j + 0.5) * dy;
          obstacleMask[idx] = isPointInObstacle(x, y);
        }
      }
    }

    /******************** Helper Function for Obstacle Check ********************/
    function isPointInObstacle(x, y) {
      let distance = Math.sqrt((x - cylinderCenterX)**2 + (y - cylinderCenterY)**2);
      return distance <= cylinderRadius;
    }

    /******************** Initialization ********************/
    function initSimulation() {
      simulationStepCount = 0;
      currentInletVelocity = 0;
      // Allocate arrays for the staggered grid:
      u = new Float32Array((Nx+1) * Ny);
      v = new Float32Array(Nx * (Ny+1));
      p = new Float32Array(Nx * Ny);
      
      // --- Pre-allocate temporary buffers ---
      uOld = new Float32Array(u.length);
      vOld = new Float32Array(v.length);
      uStar  = new Float32Array(u.length);
      vStar  = new Float32Array(v.length);
      rhs       = new Float32Array(Nx * Ny);
      pPrime    = new Float32Array(Nx * Ny);
      pPrime_new = new Float32Array(Nx * Ny);
      
      // Use precomputed obstacle mask:
      obstacle = obstacleMask;
      
      residualHistory = [];
      residualText.value = "";
      // NEW: Initialize tracer particles only if tracers are enabled
      if (tracersEnabled) {
        initTracers();
      } else {
        tracers = [];
      }
      
      drawSimulation();
      drawLegend();
      drawResidualGraph();
    }

    /******************** Updated Simulation Update with PISO Algorithm (Staggered Grid) ********************/
    function updateSimulation() {
      // Copy current velocities to pre-allocated buffers for residual computation
      uOld.set(u);
      vOld.set(v);
      
      // Gradually ramp up inlet velocity to avoid shocks
      if(simulationStepCount < rampUpSteps) {
        currentInletVelocity = (simulationStepCount / rampUpSteps) * targetInletVelocity;
      } else {
        currentInletVelocity = targetInletVelocity;
      }
      const dt_sub = dt / substepCount;
      
      // Track the maximum pressure residual across all substeps.
      let maxPressureResidual = 0;
      
      // Perform PISO substeps using staggered grid formulas
      for (let sub = 0; sub < substepCount; sub++){
         pisoStep(dt_sub);
         if (lastPResidual > maxPressureResidual) {
            maxPressureResidual = lastPResidual;
         }
      }
      
      // Compute residual differences for velocity (u and v)
      let maxResidualU = 0;
      let maxResidualV = 0;
      for (let i = 0; i < u.length; i++){
        let delta = Math.abs(u[i] - uOld[i]);
        if(delta > maxResidualU) maxResidualU = delta;
      }
      for (let i = 0; i < v.length; i++){
        let delta = Math.abs(v[i] - vOld[i]);
        if(delta > maxResidualV) maxResidualV = delta;
      }
      
      simulationStepCount++;
      
      // Include the pressure residual (maxPressureResidual) in the error norm.
      let errorNorm = Math.max(maxResidualU, maxResidualV, maxPressureResidual);
      const tolerance = 1e-3;
      if (errorNorm > tolerance) {
          let factor = errorNorm / tolerance;
          substepCount = Math.min(Math.ceil(substepCount * factor), 20);
      } else if (errorNorm < tolerance / 10 && substepCount > 1) {
          substepCount = Math.max(Math.floor(substepCount / 2), 1);
      }
      
      // Log all three residuals: U, V, and P
      let logEntry = "Time Step: " + simulationStepCount +
                     ", Substeps: " + substepCount +
                     ", U Residual: " + maxResidualU.toExponential(3) +
                     ", V Residual: " + maxResidualV.toExponential(3) +
                     ", P Residual: " + maxPressureResidual.toExponential(3) + "\n";
      residualText.value += logEntry;
      residualText.scrollTop = residualText.scrollHeight;
      
      // Push the residuals to the history for graphing
      residualHistory.push({step: simulationStepCount, residual: maxResidualU});
      residualHistory.push({step: simulationStepCount, residual: maxResidualV});
      residualHistory.push({step: simulationStepCount, residual: maxPressureResidual});

      // Adjust the global time step (dt) for the next simulation step based on the CFL condition and pressure residual.
      const previousDt = dt;
      let dt_cfl = computeAutomaticTimeStep(); // dt based solely on CFL
      
      let newDt;
      if (residualScalingEnabled) {
         // Define a pressure tolerance (adjust as needed)
         const pressureTol = 1e-3;
         let dt_pressure = dt_cfl;
         if(maxPressureResidual > pressureTol) {
             // Scale dt based on the pressure error ratio using the maximum pressure residual from substeps.
             dt_pressure = dt_cfl * (pressureTol / (maxPressureResidual + 1e-10));
         }
         // Choose the more restrictive time step
         newDt = Math.min(dt_cfl, dt_pressure);
      } else {
         newDt = dt_cfl;
      }
      
      // Limit dt increase compared to the previous dt (to keep dt changes smooth)
      const maxIncreaseFactor = 1.1;
      if(newDt > previousDt) {
          newDt = Math.min(newDt, previousDt * maxIncreaseFactor);
      }
      dt = newDt;
      document.getElementById("currentDtValue").textContent = dt.toFixed(3);
    }

    /******************** PISO Substep Function (Staggered Grid) ********************/
    function pisoStep(dt_sub) {
      // Predictor: create provisional velocities using pre-allocated buffers
      uStar.set(u);
      vStar.set(v);
      
      // ----------------- Predictor for u -----------------
      for (let j = 1; j < Ny - 1; j++){
        for (let i = 1; i < Nx; i++){
          let idx = i + j * (Nx+1);
          let x = i * dx;
          let y = (j + 0.5) * dy;
          if(isPointInObstacle(x, y)) {
            uStar[idx] = 0;
            continue;
          }
          
          if (currentVelocityScheme === "first") {
            // --- First-Order Upwinding using face fluxes for u convection ---
            // X-direction: East and West fluxes (flux = [upwind u value]^2)
            let idx_e = idx + 1;
            let u_e_avg = 0.5 * (u[idx] + u[idx_e]);
            let u_face_e = (u_e_avg >= 0) ? u[idx] : u[idx_e];
            let F_e = u_face_e * u_face_e;
            
            let idx_w = idx - 1;
            let u_w_avg = 0.5 * (u[idx_w] + u[idx]);
            let u_face_w = (u_w_avg >= 0) ? u[idx_w] : u[idx];
            let F_w = u_face_w * u_face_w;
            
            // Y-direction: north & south fluxes (flux = v * upwind u)
            // For north face, u from current cell or that above respectively.
            let u_north = u[i + (j+1)*(Nx+1)];
            let v_n = 0.5 * ( v[(i-1) + (j+1)*Nx] + v[i + (j+1)*Nx] );
            let u_face_n = (v_n >= 0) ? u[idx] : u_north;
            let F_n = v_n * u_face_n;
            
            // For south face, u from cell below or from current cell.
            let u_south = u[i + (j-1)*(Nx+1)];
            let v_s = 0.5 * ( v[(i-1) + j*Nx] + v[i + j*Nx] );
            let u_face_s = (v_s >= 0) ? u_south : u[idx];
            let F_s = v_s * u_face_s;
            
            // Convective term by flux differences.
            let convective = (F_e - F_w)/dx + (F_n - F_s)/dy;
            
            // Diffusion term (using same stencil as before)
            let idx_n = i + (j+1)*(Nx+1);
            let idx_s = i + (j-1)*(Nx+1);
            let lap_u = (u[idx_e] - 2*u[idx] + u[idx_w])/(dx*dx) +
                        (u[idx_n] - 2*u[idx] + u[idx_s])/(dy*dy);
            uStar[idx] = u[idx] + dt_sub * ( - convective + nu * lap_u );
            
          } else {
            // --- Second-Order Upwinding using face fluxes for u convection ---
            // East face flux
            let idx_e = idx + 1;
            let u_face_e = 0;
            // Decide upwinding using the u value at the left of the face.
            if(u[idx] >= 0) {
              // Use second-order reconstruction if available; otherwise, fall back to first-order.
              u_face_e = (i > 1) ? (1.5 * u[idx] - 0.5 * u[idx - 1]) : u[idx];
            } else {
              // For negative flow, use the right cell.
              u_face_e = ((idx_e + 1) < u.length && i < Nx - 1) ? (1.5 * u[idx_e] - 0.5 * u[idx_e + 1]) : u[idx_e];
            }
            let F_e = u_face_e * u_face_e;
            
            // West face flux
            let idx_w = idx - 1;
            let u_face_w = 0;
            if(u[idx_w] >= 0) {
              u_face_w = (i > 2) ? (1.5 * u[idx_w] - 0.5 * u[idx_w - 1]) : u[idx_w];
            } else {
              u_face_w = (i < Nx ? (1.5 * u[idx] - 0.5 * u[idx + 1]) : u[idx]);
            }
            let F_w = u_face_w * u_face_w;
            
            // North face flux (vertical direction)
            let idx_n = i + (j+1) * (Nx+1);
            let u_face_n = 0;
            let v_n = 0.5 * ( v[(i-1) + (j+1)*Nx] + v[i + (j+1)*Nx] );
            if(v_n >= 0) {
              u_face_n = (j > 1) ? (1.5 * u[idx] - 0.5 * u[i + (j-1)*(Nx+1)]) : u[idx];
            } else {
              u_face_n = ((i + (j+2)*(Nx+1)) < u.length && j < Ny - 1) ? (1.5 * u[idx_n] - 0.5 * u[i + (j+2)*(Nx+1)]) : u[idx_n];
            }
            let F_n = v_n * u_face_n;
            
            // South face flux
            let idx_s = i + (j-1) * (Nx+1);
            let u_face_s = 0;
            let v_s = 0.5 * ( v[(i-1) + j*Nx] + v[i + j*Nx] );
            if(v_s >= 0) {
              u_face_s = (j > 1) ? (1.5 * u[idx_s] - 0.5 * u[i + (j-2)*(Nx+1)]) : u[idx_s];
            } else {
              u_face_s = (j < Ny ? (1.5 * u[idx] - 0.5 * u[i + (j+1)*(Nx+1)]) : u[idx]);
            }
            let F_s = v_s * u_face_s;
            
            let convective = (F_e - F_w)/dx + (F_n - F_s)/dy;
            let idx_n_local = i + (j+1)*(Nx+1);
            let idx_s_local = i + (j-1)*(Nx+1);
            let lap_u = (u[idx_e] - 2*u[idx] + u[idx_w])/(dx*dx) +
                        (u[idx_n_local] - 2*u[idx] + u[idx_s_local])/(dy*dy);
            uStar[idx] = u[idx] + dt_sub * ( - convective + nu * lap_u );
          }
        }
      }
      
      // ----------------- Predictor for v -----------------
      for (let j = 1; j < Ny; j++){
        for (let i = 1; i < Nx - 1; i++){
          let idx = i + j * Nx;
          let x = (i + 0.5) * dx;
          let y = j * dy;
          if(isPointInObstacle(x, y)) {
            vStar[idx] = 0;
            continue;
          }
          
          if (currentVelocityScheme === "first") {
            // --- First-Order Upwinding using face fluxes for v convection ---
            // X-direction: Flux F = u * v at the vertical faces.
            let idx_e = idx + 1;
            let u_e = u[(i+1) + j*(Nx+1)];
            let v_face_e = (u_e >= 0) ? v[idx] : v[idx_e];
            let F_e = u_e * v_face_e;
            
            let idx_w = idx - 1;
            let u_w = u[i + j*(Nx+1)];
            let v_face_w = (u_w >= 0) ? v[idx_w] : v[idx];
            let F_w = u_w * v_face_w;
            
            // Y-direction: Flux F = (v)^2 at the horizontal faces.
            let idx_n = i + (j+1)*Nx;
            let v_n_avg = 0.5 * (v[idx] + v[idx_n]);
            let v_face_n = (v_n_avg >= 0) ? v[idx] : v[idx_n];
            let F_n = v_face_n * v_face_n;
            
            let idx_s = i + (j-1)*Nx;
            let v_s_avg = 0.5 * (v[idx_s] + v[idx]);
            let v_face_s = (v_s_avg >= 0) ? v[idx_s] : v[idx];
            let F_s = v_face_s * v_face_s;
            
            let convective = (F_e - F_w)/dx + (F_n - F_s)/dy;
            let lap_v = (v[(i+1) + j * Nx] - 2*v[idx] + v[(i-1) + j * Nx])/(dx*dx) +
                        (v[idx_n] - 2*v[idx] + v[idx_s])/(dy*dy);
            vStar[idx] = v[idx] + dt_sub * ( - convective + nu * lap_v );
            
          } else {
            // --- Second-Order Upwinding using face fluxes for v convection ---
            // East face flux for v
            let idx_e = idx + 1;
            let v_face_e = 0;
            let u_e = u[(i+1) + j*(Nx+1)];
            if(u_e >= 0) {
              v_face_e = (i > 0) ? (1.5*v[idx] - 0.5*v[idx - 1]) : v[idx];
            } else {
              v_face_e = ((idx_e + 1) < v.length && i < Nx - 2) ? (1.5 * v[idx + 1] - 0.5 * v[idx + 2]) : v[idx + 1];
            }
            let F_e = u_e * v_face_e;
            
            // West face flux for v
            let idx_w = idx - 1;
            let v_face_w = 0;
            let u_w = u[i + j*(Nx+1)];
            if(u_w >= 0) {
              v_face_w = (i > 1) ? (1.5*v[idx_w] - 0.5*v[idx_w - 1]) : v[idx_w];
            } else {
              v_face_w = (i < Nx - 1 ? (1.5*v[idx] - 0.5*v[idx + 1]) : v[idx]) ;
            }
            let F_w = u_w * v_face_w;
            
            // North face flux for v
            let idx_n = i + (j+1)*Nx;
            let v_face_n = 0;
            let v_n_avg = 0.5 * (v[idx] + v[idx_n]);
            if(v_n_avg >= 0) {
              v_face_n = (j > 1) ? (1.5*v[idx] - 0.5*v[i + (j-1)*Nx]) : v[idx];
            } else {
              v_face_n = ((i + (j+2)*Nx) < v.length && j < Ny - 1) ? (1.5*v[idx_n] - 0.5*v[i + (j+2)*Nx]) : v[idx_n];
            }
            let F_n = v_face_n * v_face_n;
            
            // South face flux for v
            let idx_s = i + (j-1)*Nx;
            let v_face_s = 0;
            let v_s_avg = 0.5 * (v[idx_s] + v[idx]);
            if(v_s_avg >= 0) {
              v_face_s = (j > 1) ? (1.5*v[idx_s] - 0.5*v[i + (j-2)*Nx]) : v[idx_s];
            } else {
              v_face_s = (j < Ny ? (1.5*v[idx] - 0.5*v[i + (j+1)*Nx]) : v[idx]);
            }
            let F_s = v_face_s * v_face_s;
            
            let convective = (F_e - F_w)/dx + (F_n - F_s)/dy;
            let lap_v = (v[(i+1) + j * Nx] - 2*v[idx] + v[(i-1) + j * Nx])/(dx*dx) +
                        (v[i + (j+1)*Nx] - 2*v[idx] + v[i + (j-1)*Nx])/(dy*dy);
            vStar[idx] = v[idx] + dt_sub * ( - convective + nu * lap_v );
          }
        }
      }
      
      // ----------------- Pressure Correction (MAC form) -----------------
      // Use pre-allocated global buffer 'rhs' and reset its values
      rhs.fill(0);
      for (let j = 0; j < Ny; j++){
        for (let i = 0; i < Nx; i++){
          let u_right = uStar[(i+1) + j*(Nx+1)];
          let u_left  = uStar[i + j*(Nx+1)];
          let v_top    = vStar[i + (j+1)*Nx];
          let v_bottom = vStar[i + j*Nx];
          let div = (u_right - u_left)/dx + (v_top - v_bottom)/dy;
          rhs[i+j*Nx] = div / dt_sub;
        }
      }
      
      if (currentPressureSolver === "sor") {
          // ---------- Pressure Correction using Successive Over-Relaxation (SOR) ----------
          pPrime.fill(0); // initialize pressure correction field
          const sorOmega = 1.7; // SOR relaxation factor (tunable)
          const pressureTolerance = 1e-4;
          let finalPResidual = Infinity;
          for (let iter = 0; iter < iterations; iter++){
              let maxError = 0;
              for (let j = 1; j < Ny-1; j++){
                  for (let i = 1; i < Nx-1; i++){
                      let idx = i + j * Nx;
                      let p_old = pPrime[idx];
                      let p_update = ((pPrime[(i+1)+j*Nx] + pPrime[(i-1)+j*Nx])/(dx*dx) +
                                      (pPrime[i+(j+1)*Nx] + pPrime[i+(j-1)*Nx])/(dy*dy) -
                                       rhs[idx]) / denom;
                      pPrime[idx] = (1 - sorOmega) * p_old + sorOmega * p_update;
                      let error = Math.abs(pPrime[idx] - p_old);
                      if (error > maxError) maxError = error;
                  }
              }
              // Enforce Neumann BC on the bottom and top boundaries
              for (let i = 0; i < Nx; i++){
                  pPrime[i] = pPrime[i+Nx]; // bottom
                  pPrime[i + (Ny-1)*Nx] = pPrime[i + (Ny-2)*Nx]; // top
              }
              // Update left (inlet) and outlet (right) boundaries
              for (let j = 0; j < Ny; j++){
                  pPrime[0+j*Nx] = pPrime[1+j*Nx];
                  pPrime[Nx-1+j*Nx] = 0;
              }
              finalPResidual = maxError;
              if (maxError < pressureTolerance) break;
          }
          lastPResidual = finalPResidual;
      } else if (currentPressureSolver === "multigrid") {
          // ---------- Pressure Correction using Multigrid V-Cycle ----------
          pPrime.fill(0); // initialize pressure correction field
          // Run several V-cycles to further smooth the solution and reduce stripe artifacts.
          let numCycles = 3;
          for (let cycle = 0; cycle < numCycles; cycle++){
              mgVcycle(pPrime, rhs, Nx, Ny, dx, dy);
          }
          // Compute final residual for logging
          let maxError = 0;
          const denomLocal = 2/(dx*dx) + 2/(dy*dy);
          for (let j = 1; j < Ny-1; j++){
              for (let i = 1; i < Nx-1; i++){
                  let idx = i + j * Nx;
                  let r = ((pPrime[(i+1)+j*Nx] + pPrime[(i-1)+j*Nx])/(dx*dx) +
                           (pPrime[i+(j+1)*Nx] + pPrime[i+(j-1)*Nx])/(dy*dy) -
                           denomLocal * pPrime[idx] - rhs[idx]);
                  if (Math.abs(r) > maxError) maxError = Math.abs(r);
              }
          }
          lastPResidual = maxError;
      } else { // Default: Pressure Correction using Jacobi Iteration
          // ---------- Pressure Correction using Jacobi Iteration ----------
          pPrime.fill(0);
          const jacobiOmega = 0.7;
          const pressureTolerance = 1e-6;
          let finalPResidual = Infinity;
          for (let iter = 0; iter < iterations; iter++){
              pPrime_new.fill(0);
              for (let j = 1; j < Ny-1; j++){
                  for (let i = 1; i < Nx-1; i++){
                      let idx = i + j * Nx;
                      let p_update = ((pPrime[(i+1)+j*Nx] + pPrime[(i-1)+j*Nx])/(dx*dx) +
                                      (pPrime[i+(j+1)*Nx] + pPrime[i+(j-1)*Nx])/(dy*dy) -
                                      rhs[idx]) / denom;
                      pPrime_new[idx] = jacobiOmega * p_update + (1 - jacobiOmega) * pPrime[idx];
                  }
              }
              let maxError = 0;
              for (let j = 1; j < Ny-1; j++){
                  for (let i = 1; i < Nx-1; i++){
                      let idx = i + j * Nx;
                      let error = Math.abs(pPrime_new[idx] - pPrime[idx]);
                      if (error > maxError) maxError = error;
                  }
              }
              finalPResidual = maxError;
              for (let j = 1; j < Ny-1; j++){
                  for (let i = 1; i < Nx-1; i++){
                      let idx = i + j * Nx;
                      pPrime[idx] = pPrime_new[idx];
                  }
              }
              for (let i = 0; i < Nx; i++){
                  pPrime[i] = pPrime[i+Nx]; // bottom
                  pPrime[i + (Ny-1)*Nx] = pPrime[i + (Ny-2)*Nx]; // top
              }
              for (let j = 0; j < Ny; j++){
                  pPrime[0+j*Nx] = pPrime[1+j*Nx]; // left (inlet)
                  pPrime[Nx-1+j*Nx] = 0; // outlet: enforce fixed pressure
              }
              if (maxError < pressureTolerance) break;
          }
          lastPResidual = finalPResidual;
      }
      
      // ----------------- Corrector Step -----------------
      for (let j = 0; j < Ny; j++){
        for (let i = 1; i < Nx; i++){
          let idx = i + j * (Nx+1);
          let pPrime_right = pPrime[i + j * Nx];
          let pPrime_left  = pPrime[(i-1) + j * Nx];
          u[idx] = uStar[idx] - dt_sub * (pPrime_right - pPrime_left) / dx;
        }
      }
      for (let j = 1; j < Ny; j++){
        for (let i = 0; i < Nx; i++){
          let idx = i + j * Nx;
          let pPrime_top    = pPrime[i + j * Nx];
          let pPrime_bottom = pPrime[i + (j-1) * Nx];
          v[idx] = vStar[idx] - dt_sub * (pPrime_top - pPrime_bottom) / dy;
        }
      }
      for (let j = 0; j < Ny; j++){
        for (let i = 0; i < Nx; i++){
          let idx = i + j * Nx;
          p[idx] += pPrime[idx];
        }
      }
      
      // Enforce boundary conditions on the updated velocities
      applyBoundaryConditions();
    }

    /******************** Boundary Conditions (Staggered Grid) ********************/
    function applyBoundaryConditions() {
      // For u:
      // Inlet: left boundary (i=0) for u; u[0,j] is set to inlet profile.
      for (let j = 0; j < Ny; j++){
        let idx = 0 + j*(Nx+1);
        let y = (j + 0.5) * dy;
        let profile = inletProfileSelect.value;
        let inletVal = currentInletVelocity;
        if(profile === "parabolic") {
          let center = Ly/2;
          let radius = Ly/2;
          inletVal = currentInletVelocity * (1 - Math.pow((y-center)/radius, 2));
          inletVal = Math.max(inletVal, 0);
        }
        u[idx] = inletVal;
      }
      // Outlet: right boundary for u (i=Nx)
      for (let j = 0; j < Ny; j++){
        let idxOutlet = Nx + j*(Nx+1);
        let idxInterior = (Nx-1) + j*(Nx+1);
        u[idxOutlet] = u[idxInterior];
      }
      
      /* Enforce no-slip for the domain top and bottom on u.
         Since u is defined on vertical faces (rows j: 0 to Ny-1),
         we force u=0 for the bottom row (j=0) and for the top row (j=Ny-1). */
      // Bottom wall (j = 0)
      for (let i = 0; i < Nx+1; i++){
         u[i + 0*(Nx+1)] = 0;
      }
      // Top wall (j = Ny-1)
      for (let i = 0; i < Nx+1; i++){
         u[i + (Ny-1)*(Nx+1)] = 0;
      }
      
      // For v:
      // Top and bottom boundaries (v faces): v[i,0]=0 and v[i,Ny]=0
      for (let i = 0; i < Nx; i++){
        v[i + 0*Nx] = 0;       // bottom
        v[i + Ny*Nx] = 0;      // top
      }
      // Enforce no-slip on obstacle: set u and v to zero at faces lying inside the cylinder
      for (let j = 0; j < Ny; j++){
        for (let i = 0; i < Nx+1; i++){
          let x = i * dx;
          let y = (j + 0.5) * dy;
          if(isPointInObstacle(x, y)) {
            u[i + j*(Nx+1)] = 0;
          }
        }
      }
      for (let j = 0; j < Ny+1; j++){
        for (let i = 0; i < Nx; i++){
          let x = (i + 0.5) * dx;
          let y = j * dy;
          if(isPointInObstacle(x, y)) {
            v[i + j*Nx] = 0;
          }
        }
      }
    }

    /******************** Utility: Compute Vorticity (cell–centered from staggered fields) ********************/
    function computeVorticity(i, j) {
      // Only compute for interior pressure cells (neighbors exist)
      if(i <= 0 || i >= Nx-1 || j <= 0 || j >= Ny-1) return 0;
      // Compute cell–centered velocity (averaging adjacent u and v)
      let u_center = 0.5 * ( u[i + j*(Nx+1)] + u[(i+1) + j*(Nx+1)] );
      let v_center = 0.5 * ( v[i + j*Nx] + v[i + (j+1)*Nx] );
      let u_north = 0.5 * ( u[i + (j+1)*(Nx+1)] + u[(i+1) + (j+1)*(Nx+1)] );
      let u_south = 0.5 * ( u[i + (j-1)*(Nx+1)] + u[(i+1) + (j-1)*(Nx+1)] );
      let v_east = 0.5 * ( v[(i+1) + j*Nx] + v[(i+1) + (j+1)*Nx] );
      let v_west = 0.5 * ( v[(i-1) + j*Nx] + v[(i-1) + (j+1)*Nx] );
      let dudy = (u_north - u_south) / (2*dy);
      let dvdx = (v_east - v_west) / (2*dx);
      return dvdx - dudy;
    }

    /******************** Visualization ********************/
    function drawSimulation() {
      // Always clear the canvas to remove previous drawings
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (currentVisualization === "tracer") {
         // NEW: If tracers are disabled, show a message instead
         if (!tracersEnabled) {
           ctx.font = "20px Arial";
           ctx.fillStyle = "red";
           ctx.fillText("Tracer particles are disabled.", canvas.width / 2 - 100, canvas.height / 2);
           return; // Skip drawing tracer particles
         }
         // Compute grid mapping as before
         const cellSize = canvas.width / Nx;
         const domainWidth = Nx * cellSize;
         const domainHeight = Ny * cellSize;
         const offsetX = (canvas.width - domainWidth) / 2;
         const offsetY = (canvas.height - domainHeight) / 2;

         // Draw tracer particles as red dots (no trails)
         for (let tracer of tracers) {
           ctx.beginPath();
           ctx.arc(
             crisp(offsetX + (tracer.x / Lx) * domainWidth),
             crisp(offsetY + (1 - tracer.y / Ly) * domainHeight),
             3, 0, 2 * Math.PI
           );
           ctx.fillStyle = "red";
           ctx.fill();
         }
         // Draw simulation domain boundaries using colored lines
         drawDomainBoundaries(cellSize, offsetX, offsetY);

         // Draw cylindrical obstacle on tracer visualization
         let iCylinder = cylinderCenterX / dx;
         let jCylinder = cylinderCenterY / dy;
         let cx = offsetX + (iCylinder - 0.5) * cellSize;
         let cy = offsetY + (Ny - jCylinder - 0.5) * cellSize;
         let cr = (cylinderRadius / dx) * cellSize;
         ctx.beginPath();
         ctx.arc(cx, cy, cr, 0, 2 * Math.PI);
         ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
         ctx.fill();
         ctx.strokeStyle = "white";
         ctx.lineWidth = 2;
         ctx.stroke();

         return; // Skip the normal field visualization when in tracer mode
      }
      
      // Regular visualization branch: (e.g., velocity, pressure, vorticity)
      // Use pressure grid dimensions for visualization
      const cellSize = canvas.width / Nx;
      const domainWidth = Nx * cellSize;
      const domainHeight = Ny * cellSize;
      const offsetX = (canvas.width - domainWidth) / 2;
      const offsetY = (canvas.height - domainHeight) / 2;
      
      // Determine min and max field values for color mapping over pressure cells
      let minVal = Infinity, maxVal = -Infinity;
      for (let j = 0; j < Ny; j++){
        for (let i = 0; i < Nx; i++){
          let idxP = i + j * Nx;
          let val;
          if(currentVisualization === "velocity") {
            // Compute cell-centered velocity by averaging u (left/right) and v (bottom/top)
            let u_center = 0.5 * ( u[i + j*(Nx+1)] + u[(i+1) + j*(Nx+1)] );
            let v_center = 0.5 * ( v[i + j*Nx] + v[i + (j+1)*Nx] );
            val = Math.sqrt(u_center**2 + v_center**2);
          } else if (currentVisualization === "pressure") {
            val = p[idxP];
          } else if (currentVisualization === "vorticity") {
            val = computeVorticity(i, j);
          }
          if(val < minVal) minVal = val;
          if(val > maxVal) maxVal = val;
        }
      }
      if(maxVal === minVal) maxVal = minVal + 1;
      
      // Draw each pressure cell
      for (let j = 0; j < Ny; j++){
        for (let i = 0; i < Nx; i++){
          let idxP = i + j * Nx;
          let val;
          if(currentVisualization === "velocity") {
            let u_center = 0.5 * ( u[i + j*(Nx+1)] + u[(i+1) + j*(Nx+1)] );
            let v_center = 0.5 * ( v[i + j*Nx] + v[i + (j+1)*Nx] );
            val = Math.sqrt(u_center**2 + v_center**2);
          } else if (currentVisualization === "pressure") {
            val = p[idxP];
          } else if (currentVisualization === "vorticity") {
            val = computeVorticity(i, j);
          }
          let normalized = (val - minVal) / (maxVal - minVal);
          let color = getColorForValue(normalized);
          let cellX = offsetX + i * cellSize;
          let cellY = offsetY + (Ny - 1 - j) * cellSize;
          ctx.fillStyle = color;
          ctx.fillRect(cellX, cellY, cellSize, cellSize);
        }
      }
      
      drawDomainBoundaries(cellSize, offsetX, offsetY);
      // Draw cylindrical obstacle on top (using pressure cell coordinates)
      let iCylinder = cylinderCenterX / dx;
      let jCylinder = cylinderCenterY / dy;
      let cx = offsetX + (iCylinder - 0.5)*cellSize;
      let cy = offsetY + (Ny - jCylinder - 0.5)*cellSize;
      let cr = (cylinderRadius/dx)*cellSize;
      ctx.beginPath();
      ctx.arc(cx, cy, cr, 0, 2 * Math.PI);
      ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
      ctx.fill();
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // Map a normalized value (0 to 1) to a color (blue for low, red for high)
    function getColorForValue(value) {
      let r = Math.floor(255 * value);
      let g = 0;
      let b = Math.floor(255 * (1 - value));
      return "rgb(" + r + "," + g + "," + b + ")";
    }

    // Draw the simulation domain boundaries using the new uniform grid mapping.
    function drawDomainBoundaries(cellSize, offsetX, offsetY) {
      const domainWidth = Nx * cellSize;
      const domainHeight = Ny * cellSize;
      
      ctx.lineWidth = 3;
      
      // Inlet (left boundary in green)
      ctx.strokeStyle = "green";
      ctx.beginPath();
      ctx.moveTo(offsetX, offsetY);
      ctx.lineTo(offsetX, offsetY + domainHeight);
      ctx.stroke();
      
      // Outlet (right boundary in blue)
      ctx.strokeStyle = "blue";
      ctx.beginPath();
      ctx.moveTo(offsetX + domainWidth, offsetY);
      ctx.lineTo(offsetX + domainWidth, offsetY + domainHeight);
      ctx.stroke();
      
      // Top and bottom walls (magenta)
      ctx.strokeStyle = "magenta";
      ctx.beginPath();
      ctx.moveTo(offsetX, offsetY);
      ctx.lineTo(offsetX + domainWidth, offsetY);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(offsetX, offsetY + domainHeight);
      ctx.lineTo(offsetX + domainWidth, offsetY + domainHeight);
      ctx.stroke();
    }

    // Plot the residual history on the residual graph canvas
    function drawResidualGraph() {
      residualCtx.clearRect(0, 0, residualCanvas.width, residualCanvas.height);
      // Draw graph axes
      residualCtx.strokeStyle = "black";
      residualCtx.beginPath();
      residualCtx.moveTo(40, 10);
      residualCtx.lineTo(40, residualCanvas.height - 30);
      residualCtx.lineTo(residualCanvas.width - 10, residualCanvas.height - 30);
      residualCtx.stroke();
      // Y-axis ticks (10 ticks)
      for(let i = 0; i <= 10; i++) {
        let y = 10 + i * ((residualCanvas.height - 40) / 10);
        residualCtx.beginPath();
        residualCtx.moveTo(35, y);
        residualCtx.lineTo(40, y);
        residualCtx.stroke();
        residualCtx.fillText(((10 - i) / 10).toFixed(1), 5, y+3);
      }
      
      // Plot residual history as a red line
      if(residualHistory.length < 2) return;
      residualCtx.strokeStyle = "red";
      residualCtx.beginPath();
      let maxStep = residualHistory[residualHistory.length - 1].step;
      let maxResidualValue = Math.max(...residualHistory.map(r => r.residual)) || 1;
      for(let i = 0; i < residualHistory.length; i++) {
        let x = 40 + (residualHistory[i].step / maxStep) * (residualCanvas.width - 50);
        let y = 10 + (1 - (residualHistory[i].residual / maxResidualValue)) * (residualCanvas.height - 40);
        if(i === 0) {
          residualCtx.moveTo(x,y);
        } else {
          residualCtx.lineTo(x,y);
        }
      }
      residualCtx.stroke();
    }

    // Draw the legend for field values in the legend canvas
    function drawLegend() {
      let width = legendCanvas.width;
      let height = legendCanvas.height;
      // Create a horizontal gradient
      let gradient = legendCtx.createLinearGradient(0, 0, width, 0);
      for (let i = 0; i <= 10; i++) {
        let value = i / 10;
        let color = getColorForValue(value);
        gradient.addColorStop(value, color);
      }
      // Clear the legend canvas
      legendCtx.clearRect(0, 0, width, height);
      // Fill the canvas with the gradient
      legendCtx.fillStyle = gradient;
      legendCtx.fillRect(0, 0, width, height);

      // Draw ticks and labels
      legendCtx.fillStyle = "black";
      legendCtx.font = "10px Arial";
      for (let i = 0; i <= 10; i++) {
        let x = (i / 10) * width;
        legendCtx.beginPath();
        legendCtx.moveTo(x, height);
        legendCtx.lineTo(x, height - 5);
        legendCtx.stroke();
        legendCtx.fillText((i / 10).toFixed(1), x - 8, height - 7);
      }
    }

    /******************** Animation Loop ********************/
    function simulationLoop() {
      if(!simulationRunning) return;
      updateSimulation();
      // NEW: Update tracers only when enabled
      if (tracersEnabled) {
         updateTracers(dt);
         if (simulationStepCount % tracerInjectionInterval === 0) {
            injectTracers();
         }
      }
      drawSimulation();
      drawResidualGraph();
      drawLegend();
      requestAnimationFrame(simulationLoop);
    }

    /******************** Event Listeners ********************/
    velocityButton.addEventListener("click", function() {
      currentVisualization = "velocity";
      drawSimulation();
      drawLegend();
    });
    pressureButton.addEventListener("click", function() {
      currentVisualization = "pressure";
      drawSimulation();
      drawLegend();
    });
    vorticityButton.addEventListener("click", function() {
      currentVisualization = "vorticity";
      drawSimulation();
      drawLegend();
    });
    tracerButton.addEventListener("click", function() {
      currentVisualization = "tracer";
      drawSimulation();
      drawLegend();
    });
    inletVelocitySlider.addEventListener("input", function() {
      targetInletVelocity = parseFloat(inletVelocitySlider.value);
      inletVelocityValue.textContent = inletVelocitySlider.value;
    });
    timeStepInput.addEventListener("change", function() {
      dt = parseFloat(timeStepInput.value);
    });
    startButton.addEventListener("click", function() {
      if(!simulationRunning) {
        simulationRunning = true;
        simulationLoop();
      }
    });
    pauseButton.addEventListener("click", function() {
      simulationRunning = false;
    });
    resetButton.addEventListener("click", function() {
      simulationRunning = false;
      initSimulation();
    });
    viscosityInput.addEventListener("input", function() {
      nu = parseFloat(viscosityInput.value);
    });
    pressureSolverSelect.addEventListener("change", function() {
      currentPressureSolver = pressureSolverSelect.value;
    });

    // Event listener for dt scaling checkbox
    const residualScalingCheckbox = document.getElementById("residualScalingCheckbox");
    residualScalingCheckbox.addEventListener("change", function() {
      residualScalingEnabled = residualScalingCheckbox.checked;
    });

    // Event listener to update the scheme variable when the user selects a different option
    velocitySchemeSelect.addEventListener("change", function() {
      currentVelocityScheme = velocitySchemeSelect.value;
    });

    // NEW: Event listener for the tracer enable/disable checkbox
    const tracerEnabledCheckbox = document.getElementById("tracerEnabledCheckbox");
    tracerEnabledCheckbox.addEventListener("change", function() {
      tracersEnabled = tracerEnabledCheckbox.checked;
      if (tracersEnabled) {
        initTracers();
      } else {
        tracers = [];
      }
    });

    // Initialize simulation when page loads
    window.onload = function() {
      precomputeObstacleMask();
      initSimulation();
    }

    /******************** Automatic Time Step Control (CFL Condition) ********************/
    function computeAutomaticTimeStep() {
      let maxVel = 0;
      // Check maximum velocity in u array
      for (let i = 0; i < u.length; i++){
        let vel = Math.abs(u[i]);
        if (vel > maxVel) maxVel = vel;
      }
      // Check maximum velocity in v array
      for (let i = 0; i < v.length; i++){
        let vel = Math.abs(v[i]);
        if (vel > maxVel) maxVel = vel;
      }
      if (maxVel === 0) {
        return parseFloat(timeStepInput.value);
      }
      const cfl = 0.5;
      let dt_cfl = cfl * Math.min(dx, dy) / maxVel;
      // Cap dt_cfl to the user-selected dt value
      let dt_user = parseFloat(timeStepInput.value);
      return Math.min(dt_cfl, dt_user);
    }

    /******************** Multigrid Solver Functions ********************/

    // Simple Jacobi smoother for multigrid; smoothes the interior cells.
    function mgSmooth(p, rhs, nx, ny, dx, dy, iterations) {
      let p_new = new Float32Array(p.length);
      const denomLocal = 2/(dx*dx) + 2/(dy*dy);
      for (let iter = 0; iter < iterations; iter++){
        for (let j = 1; j < ny - 1; j++){
          for (let i = 1; i < nx - 1; i++){
            let idx = i + j * nx;
            let p_e = p[idx + 1];
            let p_w = p[idx - 1];
            let p_n = p[i + (j+1)*nx];
            let p_s = p[i + (j-1)*nx];
            p_new[idx] = ((p_e + p_w)/(dx*dx) + (p_n + p_s)/(dy*dy) - rhs[idx]) / denomLocal;
          }
        }
        // Update interior cells with the smoothed values
        for (let j = 1; j < ny - 1; j++){
          for (let i = 1; i < nx - 1; i++){
            let idx = i + j * nx;
            p[idx] = p_new[idx];
          }
        }
      }
    }

    // Restrict fine grid residual to a coarser grid using full weighting.
    function mgRestrict(fine, nx_f, ny_f, nx_c, ny_c) {
      let coarse = new Float32Array(nx_c * ny_c);
      for (let j = 1; j < ny_c - 1; j++){
        for (let i = 1; i < nx_c - 1; i++){
          let fi = 2 * i;
          let fj = 2 * j;
          let idx_coarse = i + j * nx_c;
          let sum = fine[fi + fj*nx_f] +
                    0.5 * (fine[(fi-1) + fj*nx_f] + fine[(fi+1) + fj*nx_f] + fine[fi + (fj-1)*nx_f] + fine[fi + (fj+1)*nx_f]) +
                    0.25*(fine[(fi-1) + (fj-1)*nx_f] + fine[(fi-1) + (fj+1)*nx_f] + fine[(fi+1) + (fj-1)*nx_f] + fine[(fi+1) + (fj+1)*nx_f]);
          coarse[idx_coarse] = sum / 4;
        }
      }
      // Set boundaries by simple injection
      for (let i = 0; i < nx_c; i++){
        coarse[i] = fine[2*i]; // bottom row
        coarse[i + (ny_c - 1) * nx_c] = fine[2*i + (ny_f - 1) * nx_f]; // top row
      }
      for (let j = 0; j < ny_c; j++){
        coarse[0 + j * nx_c] = fine[0 + (2*j)*nx_f]; // left boundary
        coarse[(nx_c-1) + j * nx_c] = fine[(nx_f - 1) + (2*j)*nx_f]; // right boundary
      }
      return coarse;
    }

    // Prolongation using bilinear interpolation to reduce stripey artifacts.
    function mgProlongate(coarse, nx_c, ny_c, nx_f, ny_f) {
      let fine = new Float32Array(nx_f * ny_f);
      for (let j = 0; j < ny_f; j++){
        // Compute the fractional coarse grid coordinate in y
        let y_coarse = j / 2.0;
        let j0 = Math.floor(y_coarse);
        let j1 = Math.min(j0 + 1, ny_c - 1);
        let b = y_coarse - j0;
        for (let i = 0; i < nx_f; i++){
          // Compute the fractional coarse grid coordinate in x
          let x_coarse = i / 2.0;
          let i0 = Math.floor(x_coarse);
          let i1 = Math.min(i0 + 1, nx_c - 1);
          let a = x_coarse - i0;
          // Bilinear interpolation from the coarse grid:
          fine[i + j * nx_f] = 
             (1 - a) * (1 - b) * coarse[i0 + j0 * nx_c] +
             a * (1 - b) * coarse[i1 + j0 * nx_c] +
             (1 - a) * b * coarse[i0 + j1 * nx_c] +
             a * b * coarse[i1 + j1 * nx_c];
        }
      }
      return fine;
    }

    // Multigrid V-Cycle recursive solver.
    function mgVcycle(p, rhs, nx, ny, dx, dy) {
      const denomLocal = 2/(dx*dx) + 2/(dy*dy);
      // Pre-smoothing: increase iterations to 5 to reduce high-frequency errors.
      mgSmooth(p, rhs, nx, ny, dx, dy, 5);
      
      // Compute residual: r = rhs - A*p for interior points.
      let r = new Float32Array(nx * ny);
      for (let j = 1; j < ny - 1; j++){
        for (let i = 1; i < nx - 1; i++){
          let idx = i + j * nx;
          let p_e = p[idx + 1];
          let p_w = p[idx - 1];
          let p_n = p[i + (j+1)*nx];
          let p_s = p[i + (j-1)*nx];
          let Ap = (p_e + p_w)/(dx*dx) + (p_n + p_s)/(dy*dy) - denomLocal * p[idx];
          r[idx] = rhs[idx] - Ap;
        }
      }
      
      // If the grid is too coarse, solve directly with extra smoothing.
      if (nx <= 4 || ny <= 4) {
        mgSmooth(p, rhs, nx, ny, dx, dy, 10);
        return;
      }
      
      // Restrict the residual to the coarse grid.
      let nx_c = Math.floor((nx + 1) / 2);
      let ny_c = Math.floor((ny + 1) / 2);
      let r_coarse = mgRestrict(r, nx, ny, nx_c, ny_c);
      
      // Initialize the error on the coarse grid to zero.
      let e_coarse = new Float32Array(nx_c * ny_c);
      
      // Recursively solve for the error on the coarse grid (one V-cycle).
      mgVcycle(e_coarse, r_coarse, nx_c, ny_c, 2*dx, 2*dy);
      
      // Prolongate the coarse grid error to the fine grid.
      let e_fine = mgProlongate(e_coarse, nx_c, ny_c, nx, ny);
      
      // Correct the fine grid solution.
      for (let i = 0; i < p.length; i++){
        p[i] += e_fine[i];
      }
      
      // Post-smoothing: increase iterations to 5.
      mgSmooth(p, rhs, nx, ny, dx, dy, 5);
    }

    // **************** NEW: Tracer Particles Functions ****************
    let tracers = [];

    function initTracers() {
      tracers = [];
      // Inject one tracer per inlet cell face (one per row in the u face, total of Ny)
      for (let j = 0; j < Ny; j++) {
        let x = 0;
        let y = (j + 0.5) * dy; // place tracer at the center of the inlet cell face
        tracers.push({ x: x, y: y, initialY: y });
      }
    }

    function updateTracers(dt) {
      let updatedTracers = [];
      for (let tracer of tracers) {
        let vel = getVelocityAt(tracer.x, tracer.y);
        tracer.x += dt * vel.u;
        tracer.y += dt * vel.v;
        // Only keep tracer if it is within bounds
        if (tracer.x >= 0 && tracer.x <= Lx && tracer.y >= 0 && tracer.y <= Ly) {
          updatedTracers.push(tracer);
        }
      }
      tracers = updatedTracers;
    }

    function getVelocityAt(x, y) {
      // Bilinearly interpolate the cell-centered velocity.
      // Determine indices in the pressure (cell-centered) grid:
      let i = Math.floor(x / dx);
      let j = Math.floor(y / dy);
      if (i < 0) i = 0;
      if (i > Nx - 2) i = Nx - 2;
      if (j < 0) j = 0;
      if (j > Ny - 2) j = Ny - 2;
      let rx = (x - i * dx) / dx;
      let ry = (y - j * dy) / dy;
      
      // Helper: Compute cell-centered velocity for pressure cell (i,j)
      function cellCenterVelocity(ii, jj) {
        let u_val = 0.5 * (u[ii + jj * (Nx+1)] + u[(ii+1) + jj * (Nx+1)]);
        let v_val = 0.5 * (v[ii + jj * Nx] + v[ii + (jj+1) * Nx]);
        return { u: u_val, v: v_val };
      }
      let v00 = cellCenterVelocity(i, j);
      let v10 = cellCenterVelocity(i+1, j);
      let v01 = cellCenterVelocity(i, j+1);
      let v11 = cellCenterVelocity(i+1, j+1);
      
      let u_interp = (1 - rx) * ((1 - ry) * v00.u + ry * v01.u) + rx * ((1 - ry) * v10.u + ry * v11.u);
      let v_interp = (1 - rx) * ((1 - ry) * v00.v + ry * v01.v) + rx * ((1 - ry) * v10.v + ry * v11.v);
      return { u: u_interp, v: v_interp };
    }

    // Helper function to snap a coordinate to the nearest pixel for crisp drawing
    function crisp(val) {
      const dpr = window.devicePixelRatio || 1;
      return Math.round(val * dpr) / dpr + 0.5;
    }

    // New constant: inject new tracers every N simulation steps
    const tracerInjectionInterval = 100; // adjust as desired

    // New function: inject one tracer per inlet cell face (one per row)
    function injectTracers() {
      for (let j = 0; j < Ny; j++) {
        let x = 0;
        let y = (j + 0.5) * dy; // place tracer at the center of the inlet cell face
        tracers.push({ x: x, y: y, initialY: y });
      }
    }
  </script>
</body>
</html>
