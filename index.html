<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2D Fluid Flow Simulation with PISO Algorithm (Staggered Grid)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 10px;
    }
    #simulationContainer {
      display: flex;
      flex-wrap: wrap;
    }
    #controls {
      margin: 10px;
    }
    canvas {
      border: 1px solid #ccc;
      margin: 10px;
    }
    #residualText {
      width: 100%;
      height: 100px;
    }
  </style>
</head>
<body>
  <h1>2D Fluid Flow Simulation around a Cylindrical Obstacle (Staggered Grid)</h1>
  <div id="simulationContainer">
    <!-- Simulation visualization canvas -->
    <canvas id="simulationCanvas" width="1000" height="660"></canvas>
    <div id="controls">
      <h2>Visualization Controls</h2>
      <button id="velocityButton">Velocity Field</button>
      <button id="pressureButton">Pressure Field</button>
      <button id="vorticityButton">Vorticity Field</button>
      <h3>Legend</h3>
      <!-- Gradient legend with 10 ticks -->
      <canvas id="legendCanvas" width="200" height="30"></canvas>
      <p>
        Inlet: <span style="color: green">Green</span>, 
        Walls: <span style="color: magenta">Magenta</span>, 
        Outlet: <span style="color: blue">Blue</span>
      </p>
      <h2>Inlet Velocity Controls</h2>
      <label for="inletVelocitySlider">Velocity Magnitude (m/s):</label>
      <input type="range" id="inletVelocitySlider" min="0" max="5" step="0.1" value="1">
      <span id="inletVelocityValue">1</span>
      <br>
      <label for="inletProfileSelect">Velocity Profile:</label>
      <select id="inletProfileSelect">
        <option value="uniform">Uniform</option>
        <option value="parabolic">Parabolic</option>
      </select>
      <h2>Time Step Control</h2>
      <label for="timeStepInput">Time Step (s):</label>
      <input type="number" id="timeStepInput" step="0.001" value="0.01">
      <p>Current dt: <span id="currentDtValue">0.5</span></p>

      <!-- NEW: Updated Viscosity Control Section -->
      <h2>Viscosity Control</h2>
      <label for="viscosityInput">Viscosity (m²/s):</label>
      <input type="number" id="viscosityInput" min="0.0001" max="0.1" step="0.001" value="0.001">

      <!-- NEW: Pressure Solver Selection -->
      <h2>Pressure Solver</h2>
      <label for="pressureSolverSelect">Choose Pressure Solver:</label>
      <select id="pressureSolverSelect">
        <option value="jacobi" selected>Jacobi Iteration</option>
        <option value="sor">Successive Over-Relaxation (SOR)</option>
        <option value="multigrid">Multigrid V-Cycle</option>
      </select>

      <h2>Simulation Control</h2>
      <button id="startButton">Start</button>
      <button id="pauseButton">Pause</button>
      <button id="resetButton">Reset</button>
    </div>
  </div>
  
  <h2>Residuals Log (shows time step, substeps and residuals for each integration cycle)</h2>
  <textarea id="residualText" readonly></textarea>
  
  <h2>Residuals Graph</h2>
  <canvas id="residualCanvas" width="600" height="200"></canvas>
  
  <script>
    /******************** Simulation Setup and Global Variables ********************/
    // UPDATED: For staggered grid, we now define the pressure grid with Nx x Ny cells.
    const Nx = 200; // number of pressure cells in x
    const Ny = 132;  // number of pressure cells in y
    const Lx = 10;  
    const Ly = 6.6;
    // NEW: For pressure cells we use:
    const dx = Lx / Nx;
    const dy = Ly / Ny;
    
    // Global cylinder parameters for the obstacle (in SI units)
    const cylinderRadius = 0.5;  // meters
    const cylinderCenterX = Lx / 3;  // x-coordinate for cylinder center
    const cylinderCenterY = Ly / 2;  // y-coordinate for cylinder center

    // Canvas and contexts
    const canvas = document.getElementById("simulationCanvas");
    const ctx = canvas.getContext("2d");

    const legendCanvas = document.getElementById("legendCanvas");
    const legendCtx = legendCanvas.getContext("2d");

    const residualCanvas = document.getElementById("residualCanvas");
    const residualCtx = residualCanvas.getContext("2d");

    const residualText = document.getElementById("residualText");

    // UI Elements
    const velocityButton = document.getElementById("velocityButton");
    const pressureButton = document.getElementById("pressureButton");
    const vorticityButton = document.getElementById("vorticityButton");
    const inletVelocitySlider = document.getElementById("inletVelocitySlider");
    const inletVelocityValue = document.getElementById("inletVelocityValue");
    const inletProfileSelect = document.getElementById("inletProfileSelect");
    const timeStepInput = document.getElementById("timeStepInput");
    const startButton = document.getElementById("startButton");
    const pauseButton = document.getElementById("pauseButton");
    const resetButton = document.getElementById("resetButton");
    // NEW viscosity UI elements
    const viscosityInput = document.getElementById("viscosityInput");
    // NEW: Pressure solver UI element and selection state
    const pressureSolverSelect = document.getElementById("pressureSolverSelect");
    let currentPressureSolver = pressureSolverSelect.value;

    // Simulation state variables
    let simulationRunning = false;
    let simulationStepCount = 0;
    let substepCount = 5; // Initial number of sub-timesteps
    let dt = parseFloat(timeStepInput.value);
    let nu = 0.01; // kinematic viscosity (m^2/s)
    let currentInletVelocity = 0;
    let targetInletVelocity = parseFloat(inletVelocitySlider.value);
    const rampUpSteps = 1000;  // Ramp inlet from 0 to set value over 1000 time steps
    let residualHistory = [];  // For graphing residuals over time

    // NEW: Global variable to control the current visualization mode
    let currentVisualization = "velocity";

    // NEW: In a staggered grid the arrays have different sizes.
    // Pressure p: defined on pressure cells (Nx x Ny)
    // u: horizontal velocity defined at vertical faces ((Nx+1) x Ny)
    // v: vertical velocity defined at horizontal faces (Nx x (Ny+1))
    let u, v, p;
    let obstacle; // obstacle mask on pressure grid (size Nx x Ny)

    // --- Pre-allocated temporary buffers to avoid dynamic allocations during simulation ---
    let uOld, vOld, uStar, vStar, rhs, pPrime, pPrime_new;

    // Before the Jacobi iterations, precompute constant denominators
    const dx2 = dx * dx;
    const dy2 = dy * dy;
    const denom = 2 / dx2 + 2 / dy2;
    const iterations = 50; // Try reducing iterations from 100 if accuracy permits

    // NEW: Precompute boolean mask for the cylindrical obstacle on the pressure grid
    let obstacleMask; // Global precomputed obstacle mask

    // NEW: Global variable to track the last pressure residual from pressure correction
    let lastPResidual = 0;

    function precomputeObstacleMask() {
      obstacleMask = new Array(Nx * Ny).fill(false);
      for (let j = 0; j < Ny; j++){
        for (let i = 0; i < Nx; i++){
          let idx = i + j * Nx;
          // Pressure cell center position
          let x = (i + 0.5) * dx;
          let y = (j + 0.5) * dy;
          obstacleMask[idx] = isPointInObstacle(x, y);
        }
      }
    }

    /******************** Helper Function for Obstacle Check ********************/
    function isPointInObstacle(x, y) {
      let distance = Math.sqrt((x - cylinderCenterX)**2 + (y - cylinderCenterY)**2);
      return distance <= cylinderRadius;
    }

    /******************** Initialization ********************/
    function initSimulation() {
      simulationStepCount = 0;
      currentInletVelocity = 0;
      // Allocate arrays for staggered grid:
      u = new Float32Array((Nx+1) * Ny);    // u: (Nx+1) columns, Ny rows
      v = new Float32Array(Nx * (Ny+1));      // v: Nx columns, (Ny+1) rows
      p = new Float32Array(Nx * Ny);          // p: Nx x Ny
      
      // --- Pre-allocate temporary buffers ---
      // For residual computation:
      uOld = new Float32Array(u.length);
      vOld = new Float32Array(v.length);
      // For predictor step:
      uStar  = new Float32Array(u.length);
      vStar  = new Float32Array(v.length);
      // For pressure correction:
      rhs       = new Float32Array(Nx * Ny);
      pPrime    = new Float32Array(Nx * Ny);
      pPrime_new = new Float32Array(Nx * Ny);
      
      // ----- Use precomputed obstacle mask for pressure grid -----
      obstacle = obstacleMask;
      
      // Clear residual history and text log
      residualHistory = [];
      residualText.value = "";
      drawSimulation();
      drawLegend();
      drawResidualGraph();
    }

    /******************** Updated Simulation Update with PISO Algorithm (Staggered Grid) ********************/
    function updateSimulation() {
      // Copy current velocities to pre-allocated buffers for residual computation
      uOld.set(u);
      vOld.set(v);
      
      // Gradually ramp up inlet velocity to avoid shocks
      if(simulationStepCount < rampUpSteps) {
        currentInletVelocity = (simulationStepCount / rampUpSteps) * targetInletVelocity;
      } else {
        currentInletVelocity = targetInletVelocity;
      }
      const dt_sub = dt / substepCount;
      
      // NEW: Track the maximum pressure residual across all substeps.
      let maxPressureResidual = 0;
      
      // Perform PISO substeps using staggered grid formulas
      for (let sub = 0; sub < substepCount; sub++){
         pisoStep(dt_sub);
         if (lastPResidual > maxPressureResidual) {
            maxPressureResidual = lastPResidual;
         }
      }
      
      // Compute residual differences for velocity (u and v)
      let maxResidualU = 0;
      let maxResidualV = 0;
      for (let i = 0; i < u.length; i++){
        let delta = Math.abs(u[i] - uOld[i]);
        if(delta > maxResidualU) maxResidualU = delta;
      }
      for (let i = 0; i < v.length; i++){
        let delta = Math.abs(v[i] - vOld[i]);
        if(delta > maxResidualV) maxResidualV = delta;
      }
      
      simulationStepCount++;
      
      // NEW: Include the pressure residual (maxPressureResidual) in the error norm.
      let errorNorm = Math.max(maxResidualU, maxResidualV, maxPressureResidual);
      const tolerance = 1e-3;
      if (errorNorm > tolerance) {
          let factor = errorNorm / tolerance;
          substepCount = Math.min(Math.ceil(substepCount * factor), 20);
      } else if (errorNorm < tolerance / 10 && substepCount > 1) {
          substepCount = Math.max(Math.floor(substepCount / 2), 1);
      }
      
      // NEW: Log all three residuals: U, V, and P
      let logEntry = "Time Step: " + simulationStepCount +
                     ", Substeps: " + substepCount +
                     ", U Residual: " + maxResidualU.toExponential(3) +
                     ", V Residual: " + maxResidualV.toExponential(3) +
                     ", P Residual: " + maxPressureResidual.toExponential(3) + "\n";
      residualText.value += logEntry;
      residualText.scrollTop = residualText.scrollHeight;
      
      // NEW: Push the residuals to the history for graphing
      residualHistory.push({step: simulationStepCount, residual: maxResidualU});
      residualHistory.push({step: simulationStepCount, residual: maxResidualV});
      residualHistory.push({step: simulationStepCount, residual: maxPressureResidual});

      // ===========================================================================
      // NEW: Adjust the global time step (dt) for the next simulation step based on:
      //       - the CFL condition (velocity-based) from computeAutomaticTimeStep()
      //       - the pressure residual (reduce dt if pressure error is high)
      // ===========================================================================
      const previousDt = dt;
      let dt_cfl = computeAutomaticTimeStep(); // dt based solely on CFL
      
      // Define a pressure tolerance (adjust as needed)
      const pressureTol = 1e-3;
      let dt_pressure = dt_cfl;
      if(maxPressureResidual > pressureTol) {
          // Scale dt based on the pressure error ratio using the maximum pressure residual from substeps.
          dt_pressure = dt_cfl * (pressureTol / (maxPressureResidual + 1e-10));
      }
      // Choose the more restrictive time step
      let newDt = Math.min(dt_cfl, dt_pressure);
      
      // Limit dt increase compared to the previous dt (to keep dt changes smooth)
      const maxIncreaseFactor = 1.1;
      if(newDt > previousDt) {
          newDt = Math.min(newDt, previousDt * maxIncreaseFactor);
      }
      dt = newDt;
      document.getElementById("currentDtValue").textContent = dt.toFixed(3);
    }

    /******************** PISO Substep Function (Staggered Grid) ********************/
    function pisoStep(dt_sub) {
      // Predictor: create provisional velocities using pre-allocated buffers
      uStar.set(u);
      vStar.set(v);
      
      // ----------------- Predictor for u -----------------
      for (let j = 1; j < Ny - 1; j++){
        for (let i = 1; i < Nx; i++){
          let idx = i + j * (Nx+1);
          let x = i * dx;
          let y = (j + 0.5) * dy;
          if(isPointInObstacle(x, y)) {
            uStar[idx] = 0;
            continue;
          }
          let idx_e = (i+1) + j * (Nx+1);
          let idx_w = (i-1) + j * (Nx+1);
          let du_dx;
          if(u[idx] >= 0) {
              du_dx = (u[idx] - u[idx_w]) / dx;
          } else {
              du_dx = (u[idx_e] - u[idx]) / dx;
          }
          let v_avg = ( v[(i-1) + j * Nx] + v[i + j * Nx] +
                        v[(i-1) + (j+1) * Nx] + v[i + (j+1) * Nx] ) / 4;
          let du_dy;
          if(v_avg >= 0) {
              du_dy = (u[idx] - u[i + (j-1)*(Nx+1)]) / dy;
          } else {
              du_dy = (u[i + (j+1)*(Nx+1)] - u[idx]) / dy;
          }
          let lap_u = (u[idx_e] - 2*u[idx] + u[idx_w])/(dx*dx)
                      + (u[i + (j+1)*(Nx+1)] - 2*u[idx] + u[i + (j-1)*(Nx+1)])/(dy*dy);
          uStar[idx] = u[idx] + dt_sub * ( - (u[idx]*du_dx + v_avg*du_dy) + nu * lap_u );
        }
      }
      
      // ----------------- Predictor for v -----------------
      for (let j = 1; j < Ny; j++){
        for (let i = 1; i < Nx - 1; i++){
          let idx = i + j * Nx;
          let x = (i + 0.5) * dx;
          let y = j * dy;
          if(isPointInObstacle(x, y)) {
            vStar[idx] = 0;
            continue;
          }
          let idx_n = i + (j+1) * Nx;
          let idx_s = i + (j-1) * Nx;
          let dv_dy;
          if(v[idx] >= 0) {
              dv_dy = (v[idx] - v[i + (j-1)*Nx]) / dy;
          } else {
              dv_dy = (v[idx_n] - v[idx]) / dy;
          }
          let u_avg = ( u[(i+1) + j*(Nx+1)] + u[i + j*(Nx+1)] ) / 2;
          let dv_dx;
          if(u_avg >= 0) {
              dv_dx = (v[idx] - v[(i-1) + j * Nx]) / dx;
          } else {
              dv_dx = (v[(i+1) + j * Nx] - v[idx]) / dx;
          }
          let lap_v = (v[(i+1) + j * Nx] - 2*v[idx] + v[(i-1) + j * Nx])/(dx*dx)
                      + (v[idx_n] - 2*v[idx] + v[idx_s])/(dy*dy);
          vStar[idx] = v[idx] + dt_sub * ( - (u_avg * dv_dx + v[idx]*dv_dy) + nu * lap_v );
        }
      }
      
      // ----------------- Pressure Correction (MAC form) -----------------
      // Use pre-allocated global buffer 'rhs' and reset its values
      rhs.fill(0);
      for (let j = 0; j < Ny; j++){
        for (let i = 0; i < Nx; i++){
          let u_right = uStar[(i+1) + j*(Nx+1)];
          let u_left  = uStar[i + j*(Nx+1)];
          let v_top    = vStar[i + (j+1)*Nx];
          let v_bottom = vStar[i + j*Nx];
          let div = (u_right - u_left)/dx + (v_top - v_bottom)/dy;
          rhs[i+j*Nx] = div / dt_sub;
        }
      }
      
      if (currentPressureSolver === "sor") {
          // ---------- Pressure Correction using Successive Over-Relaxation (SOR) ----------
          pPrime.fill(0); // initialize pressure correction field
          const sorOmega = 1.7; // SOR relaxation factor (tunable)
          const pressureTolerance = 1e-4;
          let finalPResidual = Infinity;
          for (let iter = 0; iter < iterations; iter++){
              let maxError = 0;
              for (let j = 1; j < Ny-1; j++){
                  for (let i = 1; i < Nx-1; i++){
                      let idx = i + j * Nx;
                      let p_old = pPrime[idx];
                      let p_update = ((pPrime[(i+1)+j*Nx] + pPrime[(i-1)+j*Nx])/(dx*dx) +
                                      (pPrime[i+(j+1)*Nx] + pPrime[i+(j-1)*Nx])/(dy*dy) -
                                       rhs[idx]) / denom;
                      pPrime[idx] = (1 - sorOmega) * p_old + sorOmega * p_update;
                      let error = Math.abs(pPrime[idx] - p_old);
                      if (error > maxError) maxError = error;
                  }
              }
              // Enforce Neumann BC on the bottom and top boundaries
              for (let i = 0; i < Nx; i++){
                  pPrime[i] = pPrime[i+Nx]; // bottom
                  pPrime[i + (Ny-1)*Nx] = pPrime[i + (Ny-2)*Nx]; // top
              }
              // Update left (inlet) and outlet (right) boundaries
              for (let j = 0; j < Ny; j++){
                  pPrime[0+j*Nx] = pPrime[1+j*Nx];
                  pPrime[Nx-1+j*Nx] = 0;
              }
              finalPResidual = maxError;
              if (maxError < pressureTolerance) break;
          }
          lastPResidual = finalPResidual;
      } else if (currentPressureSolver === "multigrid") {
          // ---------- Pressure Correction using Multigrid V-Cycle ----------
          pPrime.fill(0); // initialize pressure correction field
          // Run several V-cycles to further smooth the solution and reduce stripe artifacts.
          let numCycles = 3;
          for (let cycle = 0; cycle < numCycles; cycle++){
              mgVcycle(pPrime, rhs, Nx, Ny, dx, dy);
          }
          // Compute final residual for logging
          let maxError = 0;
          const denomLocal = 2/(dx*dx) + 2/(dy*dy);
          for (let j = 1; j < Ny-1; j++){
              for (let i = 1; i < Nx-1; i++){
                  let idx = i + j * Nx;
                  let r = ((pPrime[(i+1)+j*Nx] + pPrime[(i-1)+j*Nx])/(dx*dx) +
                           (pPrime[i+(j+1)*Nx] + pPrime[i+(j-1)*Nx])/(dy*dy) -
                           denomLocal * pPrime[idx] - rhs[idx]);
                  if (Math.abs(r) > maxError) maxError = Math.abs(r);
              }
          }
          lastPResidual = maxError;
      } else { // Default: Pressure Correction using Jacobi Iteration
          // ---------- Pressure Correction using Jacobi Iteration ----------
          pPrime.fill(0);
          const jacobiOmega = 0.7;
          const pressureTolerance = 1e-6;
          let finalPResidual = Infinity;
          for (let iter = 0; iter < iterations; iter++){
              pPrime_new.fill(0);
              for (let j = 1; j < Ny-1; j++){
                  for (let i = 1; i < Nx-1; i++){
                      let idx = i + j * Nx;
                      let p_update = ((pPrime[(i+1)+j*Nx] + pPrime[(i-1)+j*Nx])/(dx*dx) +
                                      (pPrime[i+(j+1)*Nx] + pPrime[i+(j-1)*Nx])/(dy*dy) -
                                      rhs[idx]) / denom;
                      pPrime_new[idx] = jacobiOmega * p_update + (1 - jacobiOmega) * pPrime[idx];
                  }
              }
              let maxError = 0;
              for (let j = 1; j < Ny-1; j++){
                  for (let i = 1; i < Nx-1; i++){
                      let idx = i + j * Nx;
                      let error = Math.abs(pPrime_new[idx] - pPrime[idx]);
                      if (error > maxError) maxError = error;
                  }
              }
              finalPResidual = maxError;
              for (let j = 1; j < Ny-1; j++){
                  for (let i = 1; i < Nx-1; i++){
                      let idx = i + j * Nx;
                      pPrime[idx] = pPrime_new[idx];
                  }
              }
              for (let i = 0; i < Nx; i++){
                  pPrime[i] = pPrime[i+Nx]; // bottom
                  pPrime[i + (Ny-1)*Nx] = pPrime[i + (Ny-2)*Nx]; // top
              }
              for (let j = 0; j < Ny; j++){
                  pPrime[0+j*Nx] = pPrime[1+j*Nx]; // left (inlet)
                  pPrime[Nx-1+j*Nx] = 0; // outlet: enforce fixed pressure
              }
              if (maxError < pressureTolerance) break;
          }
          lastPResidual = finalPResidual;
      }
      
      // ----------------- Corrector Step -----------------
      for (let j = 0; j < Ny; j++){
        for (let i = 1; i < Nx; i++){
          let idx = i + j * (Nx+1);
          let pPrime_right = pPrime[i + j * Nx];
          let pPrime_left  = pPrime[(i-1) + j * Nx];
          u[idx] = uStar[idx] - dt_sub * (pPrime_right - pPrime_left) / dx;
        }
      }
      for (let j = 1; j < Ny; j++){
        for (let i = 0; i < Nx; i++){
          let idx = i + j * Nx;
          let pPrime_top    = pPrime[i + j * Nx];
          let pPrime_bottom = pPrime[i + (j-1) * Nx];
          v[idx] = vStar[idx] - dt_sub * (pPrime_top - pPrime_bottom) / dy;
        }
      }
      for (let j = 0; j < Ny; j++){
        for (let i = 0; i < Nx; i++){
          let idx = i + j * Nx;
          p[idx] += pPrime[idx];
        }
      }
      
      // Enforce boundary conditions on the updated velocities
      applyBoundaryConditions();
    }

    /******************** Boundary Conditions (Staggered Grid) ********************/
    function applyBoundaryConditions() {
      // For u:
      // Inlet: left boundary (i=0) for u; u[0,j] is set to inlet profile.
      for (let j = 0; j < Ny; j++){
        let idx = 0 + j*(Nx+1);
        let y = (j + 0.5) * dy;
        let profile = inletProfileSelect.value;
        let inletVal = currentInletVelocity;
        if(profile === "parabolic") {
          let center = Ly/2;
          let radius = Ly/2;
          inletVal = currentInletVelocity * (1 - Math.pow((y-center)/radius, 2));
          inletVal = Math.max(inletVal, 0);
        }
        u[idx] = inletVal;
      }
      // Outlet: right boundary for u (i=Nx)
      for (let j = 0; j < Ny; j++){
        let idxOutlet = Nx + j*(Nx+1);
        let idxInterior = (Nx-1) + j*(Nx+1);
        u[idxOutlet] = u[idxInterior];
      }
      
      /* NEW: Enforce no-slip for the domain top and bottom on u.
         Since u is defined on vertical faces (rows j: 0 to Ny-1),
         we force u=0 for the bottom row (j=0) and for the top row (j=Ny-1). */
      // Bottom wall (j = 0)
      for (let i = 0; i < Nx+1; i++){
         u[i + 0*(Nx+1)] = 0;
      }
      // Top wall (j = Ny-1)
      for (let i = 0; i < Nx+1; i++){
         u[i + (Ny-1)*(Nx+1)] = 0;
      }
      
      // For v:
      // Top and bottom boundaries (v faces): v[i,0]=0 and v[i,Ny]=0
      for (let i = 0; i < Nx; i++){
        v[i + 0*Nx] = 0;       // bottom
        v[i + Ny*Nx] = 0;      // top
      }
      // Enforce no-slip on obstacle: set u and v to zero at faces lying inside the cylinder
      for (let j = 0; j < Ny; j++){
        for (let i = 0; i < Nx+1; i++){
          let x = i * dx;
          let y = (j + 0.5) * dy;
          if(isPointInObstacle(x, y)) {
            u[i + j*(Nx+1)] = 0;
          }
        }
      }
      for (let j = 0; j < Ny+1; j++){
        for (let i = 0; i < Nx; i++){
          let x = (i + 0.5) * dx;
          let y = j * dy;
          if(isPointInObstacle(x, y)) {
            v[i + j*Nx] = 0;
          }
        }
      }
    }

    /******************** Utility: Compute Vorticity (cell–centered from staggered fields) ********************/
    function computeVorticity(i, j) {
      // Only compute for interior pressure cells (neighbors exist)
      if(i <= 0 || i >= Nx-1 || j <= 0 || j >= Ny-1) return 0;
      // Compute cell–centered velocity (averaging adjacent u and v)
      let u_center = 0.5 * ( u[i + j*(Nx+1)] + u[(i+1) + j*(Nx+1)] );
      let v_center = 0.5 * ( v[i + j*Nx] + v[i + (j+1)*Nx] );
      let u_north = 0.5 * ( u[i + (j+1)*(Nx+1)] + u[(i+1) + (j+1)*(Nx+1)] );
      let u_south = 0.5 * ( u[i + (j-1)*(Nx+1)] + u[(i+1) + (j-1)*(Nx+1)] );
      let v_east = 0.5 * ( v[(i+1) + j*Nx] + v[(i+1) + (j+1)*Nx] );
      let v_west = 0.5 * ( v[(i-1) + j*Nx] + v[(i-1) + (j+1)*Nx] );
      let dudy = (u_north - u_south) / (2*dy);
      let dvdx = (v_east - v_west) / (2*dx);
      return dvdx - dudy;
    }

    /******************** Visualization ********************/
    function drawSimulation() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // UPDATED: Use pressure grid dimensions for visualization
      const cellSize = canvas.width / Nx; 
      const domainWidth = Nx * cellSize;
      const domainHeight = Ny * cellSize;
      const offsetX = (canvas.width - domainWidth) / 2;
      const offsetY = (canvas.height - domainHeight) / 2;
      
      // Determine min and max field values for color mapping over pressure cells
      let minVal = Infinity, maxVal = -Infinity;
      for (let j = 0; j < Ny; j++){
        for (let i = 0; i < Nx; i++){
          let idxP = i + j * Nx;
          let val;
          if(currentVisualization === "velocity") {
            // Compute cell-centered velocity by averaging u (left/right) and v (bottom/top)
            let u_center = 0.5 * ( u[i + j*(Nx+1)] + u[(i+1) + j*(Nx+1)] );
            let v_center = 0.5 * ( v[i + j*Nx] + v[i + (j+1)*Nx] );
            val = Math.sqrt(u_center**2 + v_center**2);
          } else if (currentVisualization === "pressure") {
            val = p[idxP];
          } else if (currentVisualization === "vorticity") {
            val = computeVorticity(i, j);
          }
          if(val < minVal) minVal = val;
          if(val > maxVal) maxVal = val;
        }
      }
      if(maxVal === minVal) maxVal = minVal + 1;
      
      // Draw each pressure cell
      for (let j = 0; j < Ny; j++){
        for (let i = 0; i < Nx; i++){
          let idxP = i + j * Nx;
          let val;
          if(currentVisualization === "velocity") {
            let u_center = 0.5 * ( u[i + j*(Nx+1)] + u[(i+1) + j*(Nx+1)] );
            let v_center = 0.5 * ( v[i + j*Nx] + v[i + (j+1)*Nx] );
            val = Math.sqrt(u_center**2 + v_center**2);
          } else if (currentVisualization === "pressure") {
            val = p[idxP];
          } else if (currentVisualization === "vorticity") {
            val = computeVorticity(i, j);
          }
          let normalized = (val - minVal) / (maxVal - minVal);
          let color = getColorForValue(normalized);
          let cellX = offsetX + i * cellSize;
          let cellY = offsetY + (Ny - 1 - j) * cellSize;
          ctx.fillStyle = color;
          ctx.fillRect(cellX, cellY, cellSize, cellSize);
        }
      }
      
      drawDomainBoundaries(cellSize, offsetX, offsetY);
      // Draw cylindrical obstacle on top (using pressure cell coordinates)
      let iCylinder = cylinderCenterX / dx;
      let jCylinder = cylinderCenterY / dy;
      let cx = offsetX + (iCylinder - 0.5)*cellSize;
      let cy = offsetY + (Ny - jCylinder - 0.5)*cellSize;
      let cr = (cylinderRadius/dx)*cellSize;
      ctx.beginPath();
      ctx.arc(cx, cy, cr, 0, 2 * Math.PI);
      ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
      ctx.fill();
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // Map a normalized value (0 to 1) to a color (blue for low, red for high)
    function getColorForValue(value) {
      let r = Math.floor(255 * value);
      let g = 0;
      let b = Math.floor(255 * (1 - value));
      return "rgb(" + r + "," + g + "," + b + ")";
    }

    // Draw the simulation domain boundaries using the new uniform grid mapping.
    function drawDomainBoundaries(cellSize, offsetX, offsetY) {
      const domainWidth = Nx * cellSize;
      const domainHeight = Ny * cellSize;
      
      ctx.lineWidth = 3;
      
      // Inlet (left boundary in green)
      ctx.strokeStyle = "green";
      ctx.beginPath();
      ctx.moveTo(offsetX, offsetY);
      ctx.lineTo(offsetX, offsetY + domainHeight);
      ctx.stroke();
      
      // Outlet (right boundary in blue)
      ctx.strokeStyle = "blue";
      ctx.beginPath();
      ctx.moveTo(offsetX + domainWidth, offsetY);
      ctx.lineTo(offsetX + domainWidth, offsetY + domainHeight);
      ctx.stroke();
      
      // Top and bottom walls (magenta)
      ctx.strokeStyle = "magenta";
      ctx.beginPath();
      ctx.moveTo(offsetX, offsetY);
      ctx.lineTo(offsetX + domainWidth, offsetY);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(offsetX, offsetY + domainHeight);
      ctx.lineTo(offsetX + domainWidth, offsetY + domainHeight);
      ctx.stroke();
    }

    // Plot the residual history on the residual graph canvas
    function drawResidualGraph() {
      residualCtx.clearRect(0, 0, residualCanvas.width, residualCanvas.height);
      // Draw graph axes
      residualCtx.strokeStyle = "black";
      residualCtx.beginPath();
      residualCtx.moveTo(40, 10);
      residualCtx.lineTo(40, residualCanvas.height - 30);
      residualCtx.lineTo(residualCanvas.width - 10, residualCanvas.height - 30);
      residualCtx.stroke();
      // Y-axis ticks (10 ticks)
      for(let i = 0; i <= 10; i++) {
        let y = 10 + i * ((residualCanvas.height - 40) / 10);
        residualCtx.beginPath();
        residualCtx.moveTo(35, y);
        residualCtx.lineTo(40, y);
        residualCtx.stroke();
        residualCtx.fillText(((10 - i) / 10).toFixed(1), 5, y+3);
      }
      
      // Plot residual history as a red line
      if(residualHistory.length < 2) return;
      residualCtx.strokeStyle = "red";
      residualCtx.beginPath();
      let maxStep = residualHistory[residualHistory.length - 1].step;
      let maxResidualValue = Math.max(...residualHistory.map(r => r.residual)) || 1;
      for(let i = 0; i < residualHistory.length; i++) {
        let x = 40 + (residualHistory[i].step / maxStep) * (residualCanvas.width - 50);
        let y = 10 + (1 - (residualHistory[i].residual / maxResidualValue)) * (residualCanvas.height - 40);
        if(i === 0) {
          residualCtx.moveTo(x,y);
        } else {
          residualCtx.lineTo(x,y);
        }
      }
      residualCtx.stroke();
    }

    /******************** Animation Loop ********************/
    function simulationLoop() {
      if(!simulationRunning) return;
      updateSimulation();
      drawSimulation();
      drawResidualGraph();
      requestAnimationFrame(simulationLoop);
    }

    /******************** Event Listeners ********************/
    velocityButton.addEventListener("click", function() {
      currentVisualization = "velocity";
      drawSimulation();
      drawLegend();
    });
    pressureButton.addEventListener("click", function() {
      currentVisualization = "pressure";
      drawSimulation();
      drawLegend();
    });
    vorticityButton.addEventListener("click", function() {
      currentVisualization = "vorticity";
      drawSimulation();
      drawLegend();
    });
    inletVelocitySlider.addEventListener("input", function() {
      targetInletVelocity = parseFloat(inletVelocitySlider.value);
      inletVelocityValue.textContent = inletVelocitySlider.value;
    });
    timeStepInput.addEventListener("change", function() {
      dt = parseFloat(timeStepInput.value);
    });
    startButton.addEventListener("click", function() {
      if(!simulationRunning) {
        simulationRunning = true;
        simulationLoop();
      }
    });
    pauseButton.addEventListener("click", function() {
      simulationRunning = false;
    });
    resetButton.addEventListener("click", function() {
      simulationRunning = false;
      initSimulation();
    });
    viscosityInput.addEventListener("input", function() {
      nu = parseFloat(viscosityInput.value);
    });
    pressureSolverSelect.addEventListener("change", function() {
      currentPressureSolver = pressureSolverSelect.value;
    });

    // Initialize simulation when page loads
    window.onload = function() {
      precomputeObstacleMask();
      initSimulation();
    }

    /******************** Automatic Time Step Control (CFL Condition) ********************/
    function computeAutomaticTimeStep() {
      let maxVel = 0;
      // Check maximum velocity in u array
      for (let i = 0; i < u.length; i++){
        let vel = Math.abs(u[i]);
        if (vel > maxVel) maxVel = vel;
      }
      // Check maximum velocity in v array
      for (let i = 0; i < v.length; i++){
        let vel = Math.abs(v[i]);
        if (vel > maxVel) maxVel = vel;
      }
      if (maxVel === 0) {
        return parseFloat(timeStepInput.value);
      }
      const cfl = 0.5;
      let dt_cfl = cfl * Math.min(dx, dy) / maxVel;
      // Cap dt_cfl to the user-selected dt value
      let dt_user = parseFloat(timeStepInput.value);
      return Math.min(dt_cfl, dt_user);
    }

    /******************** Multigrid Solver Functions ********************/

    // Simple Jacobi smoother for multigrid; smoothes the interior cells.
    function mgSmooth(p, rhs, nx, ny, dx, dy, iterations) {
      let p_new = new Float32Array(p.length);
      const denomLocal = 2/(dx*dx) + 2/(dy*dy);
      for (let iter = 0; iter < iterations; iter++){
        for (let j = 1; j < ny - 1; j++){
          for (let i = 1; i < nx - 1; i++){
            let idx = i + j * nx;
            let p_e = p[idx + 1];
            let p_w = p[idx - 1];
            let p_n = p[i + (j+1)*nx];
            let p_s = p[i + (j-1)*nx];
            p_new[idx] = ((p_e + p_w)/(dx*dx) + (p_n + p_s)/(dy*dy) - rhs[idx]) / denomLocal;
          }
        }
        // Update interior cells with the smoothed values
        for (let j = 1; j < ny - 1; j++){
          for (let i = 1; i < nx - 1; i++){
            let idx = i + j * nx;
            p[idx] = p_new[idx];
          }
        }
      }
    }

    // Restrict fine grid residual to a coarser grid using full weighting.
    function mgRestrict(fine, nx_f, ny_f, nx_c, ny_c) {
      let coarse = new Float32Array(nx_c * ny_c);
      for (let j = 1; j < ny_c - 1; j++){
        for (let i = 1; i < nx_c - 1; i++){
          let fi = 2 * i;
          let fj = 2 * j;
          let idx_coarse = i + j * nx_c;
          let sum = fine[fi + fj*nx_f] +
                    0.5 * (fine[(fi-1) + fj*nx_f] + fine[(fi+1) + fj*nx_f] + fine[fi + (fj-1)*nx_f] + fine[fi + (fj+1)*nx_f]) +
                    0.25*(fine[(fi-1) + (fj-1)*nx_f] + fine[(fi-1) + (fj+1)*nx_f] + fine[(fi+1) + (fj-1)*nx_f] + fine[(fi+1) + (fj+1)*nx_f]);
          coarse[idx_coarse] = sum / 4;
        }
      }
      // Set boundaries by simple injection
      for (let i = 0; i < nx_c; i++){
        coarse[i] = fine[2*i]; // bottom row
        coarse[i + (ny_c - 1) * nx_c] = fine[2*i + (ny_f - 1) * nx_f]; // top row
      }
      for (let j = 0; j < ny_c; j++){
        coarse[0 + j * nx_c] = fine[0 + (2*j)*nx_f]; // left boundary
        coarse[(nx_c-1) + j * nx_c] = fine[(nx_f - 1) + (2*j)*nx_f]; // right boundary
      }
      return coarse;
    }

    // Updated prolongation using bilinear interpolation to reduce stripey artifacts.
    function mgProlongate(coarse, nx_c, ny_c, nx_f, ny_f) {
      let fine = new Float32Array(nx_f * ny_f);
      for (let j = 0; j < ny_f; j++){
        // Compute the fractional coarse grid coordinate in y
        let y_coarse = j / 2.0;
        let j0 = Math.floor(y_coarse);
        let j1 = Math.min(j0 + 1, ny_c - 1);
        let b = y_coarse - j0;
        for (let i = 0; i < nx_f; i++){
          // Compute the fractional coarse grid coordinate in x
          let x_coarse = i / 2.0;
          let i0 = Math.floor(x_coarse);
          let i1 = Math.min(i0 + 1, nx_c - 1);
          let a = x_coarse - i0;
          // Bilinear interpolation from the coarse grid:
          fine[i + j * nx_f] = 
             (1 - a) * (1 - b) * coarse[i0 + j0 * nx_c] +
             a * (1 - b) * coarse[i1 + j0 * nx_c] +
             (1 - a) * b * coarse[i0 + j1 * nx_c] +
             a * b * coarse[i1 + j1 * nx_c];
        }
      }
      return fine;
    }

    // Multigrid V-Cycle recursive solver.
    function mgVcycle(p, rhs, nx, ny, dx, dy) {
      const denomLocal = 2/(dx*dx) + 2/(dy*dy);
      // Pre-smoothing: increase iterations to 5 to reduce high-frequency errors.
      mgSmooth(p, rhs, nx, ny, dx, dy, 5);
      
      // Compute residual: r = rhs - A*p for interior points.
      let r = new Float32Array(nx * ny);
      for (let j = 1; j < ny - 1; j++){
        for (let i = 1; i < nx - 1; i++){
          let idx = i + j * nx;
          let p_e = p[idx + 1];
          let p_w = p[idx - 1];
          let p_n = p[i + (j+1)*nx];
          let p_s = p[i + (j-1)*nx];
          let Ap = (p_e + p_w)/(dx*dx) + (p_n + p_s)/(dy*dy) - denomLocal * p[idx];
          r[idx] = rhs[idx] - Ap;
        }
      }
      
      // If the grid is too coarse, solve directly with extra smoothing.
      if (nx <= 4 || ny <= 4) {
        mgSmooth(p, rhs, nx, ny, dx, dy, 10);
        return;
      }
      
      // Restrict the residual to the coarse grid.
      let nx_c = Math.floor((nx + 1) / 2);
      let ny_c = Math.floor((ny + 1) / 2);
      let r_coarse = mgRestrict(r, nx, ny, nx_c, ny_c);
      
      // Initialize the error on the coarse grid to zero.
      let e_coarse = new Float32Array(nx_c * ny_c);
      
      // Recursively solve for the error on the coarse grid (one V-cycle).
      mgVcycle(e_coarse, r_coarse, nx_c, ny_c, 2*dx, 2*dy);
      
      // Prolongate the coarse grid error to the fine grid.
      let e_fine = mgProlongate(e_coarse, nx_c, ny_c, nx, ny);
      
      // Correct the fine grid solution.
      for (let i = 0; i < p.length; i++){
        p[i] += e_fine[i];
      }
      
      // Post-smoothing: increase iterations to 5.
      mgSmooth(p, rhs, nx, ny, dx, dy, 5);
    }
  </script>
</body>
</html>
